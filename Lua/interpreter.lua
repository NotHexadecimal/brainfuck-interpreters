---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by rm.
--- DateTime: 10/3/21 6:13 PM
---

local code = {}
local program_counter = 1
local values = {}
local pointer = 1
setmetatable(values, {__index = function() return 0 end})
local function v() return values[pointer] end
local function p(val) return function() pointer = pointer + val end end
local function add(val) return function() values[pointer] = (values[pointer] + val) % 256 end end
local function out()
    if arg[2] then
        return function()
            io.write(string.char(v()))
            io.flush()
        end
    else
        return function () io.write(string.char(v())) end
    end
end
local function input() values[pointer] = string.byte(io.read(1)) end
local function bez(pc) return function() if v() == 0 then program_counter = pc end end end
local function bnz(pc) return function() if v() ~= 0 then program_counter = pc end end end

local _text
local file = io.open(arg[1])
if file then
    _text = file:read("a")
end
local text = {}
for v in string.gmatch(_text, "[<>%.,%+%-%[%]]") do
    table.insert(text, v)
end
--print("phase 1 optimization")
local r_pos = 1 -- read position from code
local op -- this variable stores the instruction currently being condensed, if we read something different than
-- the value of to_condense then we have to stop condensing the previous value and start with a new one
while r_pos <= #text do
    local occurrences = 1 -- counts the occurrences of a given instruction to condense
    -- read all instructions and start condensing
    op = text[r_pos] -- read the instruction to condense
    if op ~= '[' and op ~= ']' and op ~= '.' and op ~= ',' then
        -- do not optimize loop conditions
        while op == text[r_pos + 1] do
            -- count all instructions that are consecutively the same
            occurrences = occurrences + 1
            r_pos = r_pos + 1
        end -- at the end r_pos has the same value of the last insruction that we could condense
    end
        if op == ">" then op = p(occurrences)
    elseif op == "<" then op = p(- occurrences)
    elseif op == "+" then op = add(occurrences)
    elseif op == "-" then op = add(- occurrences)
    elseif op == "." then op = out()
    elseif op == "," then op = input end
    -- [ and ] need to be set up later
    table.insert(code, op)
    r_pos = r_pos + 1
end
-- optimize code (optimize loops by storing the pointers for the end or start of sequence)
--print("phase 2 optimization")
local pos = 1
while pos <= #code do
    -- read all instructions and match on every '['
    if code[pos] == '[' then
        local scanning, to_close = pos + 1, 0
        while true do
            if code[scanning] == '[' then
                to_close = to_close + 1
            elseif code[scanning] == ']' then
                if to_close == 0 then
                    break
                end
                to_close = to_close - 1
            end
            scanning = scanning + 1
        end
        code[pos] = bez(scanning) -- set the argument for the start of the loop to the end pointer
        code[scanning] = bnz(pos) -- set the argument for the end of the loop to the start pointer
    end
    pos = pos + 1
end
-- print("finished optimizing")
while program_counter <= #code do
    code[program_counter]()
    program_counter = program_counter + 1
end
